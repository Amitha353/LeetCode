https://www.youtube.com/watch?v=X9LgqjSsoBU
https://github.com/zebointexas/Share_Resource/blob/main/Amazon_OA_2020_Min_Distance_Between_Robots

/* The year is 2125 and Amazon has built a galactic-scale warehouse on the edge of the Orion Spur of the Milky Way Galaxy. The warehouse is a single story space station measuring 1E9 meters in length and width(1 billion meters, or approximately 3.3 light seconds). The warehouse runs a fleet of up to 10,000 autonomuous robots which magnetically attach to the floor of the station, eliminating the need for artificial gravity. Amazon has asked you to find the squared distance between the two closest robots.

    Given the position of n robots in the warehouse, write an algorithm to find the squared shortest distance between them.
    
    
    Input:
    The function/method consists of three arguments:
    - numRobots, an integer representing the number
*/

import java.util.*;

public class HelloWorld{

     public static void main(String []args){
// Point[] points = new Point[7];

//             points[0] = new Point(1, 1);
//             points[1] = new Point(1, 9);
//             points[2] = new Point(2, 5);
//             points[3] = new Point(3, 1);
//             points[4] = new Point(4, 4);
//             points[5] = new Point(5, 8);
//             points[6] = new Point(6, 2);

            int numRobots = 3;
            int[] positionX = {0, 1, 2};
            int[] positionY = {0, 1, 4};
           Point[] points = new Point[numRobots];
           
           for(int i = 0; i < numRobots; i++) {
               points[i] = new Point(positionX[i], positionY[i]);
           }

            Arrays.sort(points, new Comparator<Point>()
            {
                @Override
                public int compare(Point p1, Point p2)
                {
                    return (p1.x > p2.x) ? 1 : (p1.x == p2.x) ? 0 : -1;
                }

            });
            System.out.println(divide(0, points.length-1, points));     
     }
     
     public static double divide(int left, int right, Point[] points)
        {
            double curMinDis = 1e20;
            if (left == right)
            {
                return curMinDis;
            }
            if (left + 1 == right)
            {
                return distance(points[left], points[right]);
            }

            int middle = (left + right) >> 1;
            double leftMinDis = divide(left, middle, points);
            double rightMinDis = divide(middle, right, points);

            curMinDis = (leftMinDis <= rightMinDis) ? leftMinDis : rightMinDis;

            List<Integer> validPointIndex = new ArrayList<>();
            for (int i = left; i <= right; i++)
            {
                if (Math.abs(points[middle].x - points[i].x) <= curMinDis)
                {
                    validPointIndex.add(i);
                }
            }
            for (int i = 0; i < validPointIndex.size() - 1; i++)
            {
                for (int j = i + 1; j < validPointIndex.size(); j++)
                {
                    
                    if (Math.abs(points[validPointIndex.get(i)].y
                            - points[validPointIndex.get(j)].y) > curMinDis)
                    {
                        continue;
                    }
                    double tempDis = distance(points[validPointIndex.get(i)],
                            points[validPointIndex.get(j)]);

                    curMinDis = (tempDis < curMinDis) ? tempDis : curMinDis;
                }
            }

            return curMinDis;
        }

        
        public static double distance(Point p1, Point p2)
        {
            // return Math.sqrt((p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x));
            return (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);
        }


        
        static class Point {
            public int x;
            public int y;

            Point(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
}
