public class Solution {
    
    class Point implements Comparable<Point> {
        int x, y, dis;
        String path;
        Point(int x, int y, int dis, String path) {
            this.x = x;
            this.y = y;
            this.dis = dis;
            this.path = path;
        }
        
        public int compareTo(Point point) {
            return this.dis == point.dis ? this.path.compareTo(point.path) : this.dis - point.dis;
        }
    }
    /**
     * @param maze: the maze
     * @param ball: the ball position
     * @param hole: the hole position
     * @return: the lexicographically smallest way
     */
    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        // write your code here
        int rows = maze.length;
        int cols = maze[0].length;
        boolean[][] visited = new boolean[rows][cols];
        
        PriorityQueue<Point> pq = new PriorityQueue<>();
        pq.offer(new Point(ball[0], ball[1], 0, ""));
        
        // array used for exploring 4 directions from a point
        char[] dstr = {'u', 'd', 'l', 'r'};
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        
        while(!pq.isEmpty()) {
            Point position = pq.poll();
            if(position.x == hole[0] && position.y == hole[1]) {
                return position.path;
            }
            
            for(int i = 0; i < dirs.length; i++) {
                int x = position.x;
                int y = position.y;
                int dis = position.dis;
                String path = position.path;
                
                //Explore the directions until hitting a wall or hole
                while(x >= 0 && x < rows && y >= 0 && y < cols && maze[x][y] == 0 && (x != hole[0] || y != hole[1])) {
                    x += dirs[i][0];
                    y += dirs[i][1];
                    dis += 1;
                }
                
                // if the ball did not encounter the hole, we need to roll back one step to get the right position that ball can reach (in range)
                if(x != hole[0] || y != hole[1]) {
                    x -= dirs[i][0];
                    y -= dirs[i][1];
                    dis -= 1;
                }
                
                if(!visited[x][y]) {
                    visited[position.x][position.y] = true;
                    pq.offer(new Point(x, y, dis, path+dstr[i]));
                }
            }
        }
        return "impossible";
    }
    
}

/*
BFS
Time complexity of O (m * n * Max (m, n)) 
Spatial complexity is O (mn)
*/
