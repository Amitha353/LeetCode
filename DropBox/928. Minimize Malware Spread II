class Solution {
    class UF {
        int[] parent;
        int[] size;
        
        UF(int n) {
            parent = new int[n];
            size = new int[n];
            
            for(int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
         }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if(rootX != rootY) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            }
        }
        
        public int find(int x) {
            if(parent[x] == x) {
                return x;
            }
            return parent[x] = find(parent[x]);
        }
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        if(initial.length == 1) {
            return initial[0];
        }
        
        Arrays.sort(initial);
        int max= n, res = -1;
        for(int k = 0; k < initial.length; k++) {
            UF uf = new UF(n);
            int removePt = initial[k];
            for(int i = 0; i < n; i++) {
                if(i == removePt)  continue; 
                for(int j = i+1; j < n; j++) {
                    if(j == removePt) continue;
                    if(graph[i][j] == 1) {
                        uf.union(i, j);
                    }
                }
            }
            int totalInfected = 0;
            Set<Integer> seen = new HashSet<>();
            for(int init: initial) {
                if(init == removePt) continue;
                int root = uf.find(init);
                int size = uf.size[root];
                if(!seen.contains(root)) {
                    seen.add(root);
                    totalInfected += size;
                }
            }
            if(max > totalInfected) {
                max = totalInfected;
                res = removePt;
            }
        }
        return res;
    }
}

/*
Let G be the graph with all the nodes in initial removed.
For each component of G

1. Traverse through the initial array
2. Within the graph, skip the intial points, check the neighbours (i, j=i+1)
3. If the graph cell for (i,j) == 1, connect the component as it is effected.
4. Create a Hashset to identify the number of components seen/effected
5. Traverse the initial array, extract the root from parent array and size from size array.
6. If the root is not in the set, then add the root to the set and size of root to the total malware count.
7. If the totalMalCount less than max, replace max, and res is the respective initial array value.

Complexity Analysis

Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.

Space Complexity: O(N).

*/
