class Solution {
    class UF {
        int[] parent;
        int[] size;
        
        public UF(int n) {
            parent = new int[n];
            size = new int[n];
            
            for(int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        public int[] getParent() {
            return parent;
        }
        
        public int[] getSize() {
            return size;
        }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if(rootX != rootY) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            }
        }
        
        public int find(int x) {
            if(parent[x] == x) {
                return x;
            }
            return parent[x]=find(parent[x]);
        }
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        
        UF uf = new UF(n);
        
        for(int i = 0; i < n; i++) {
            for(int j = i+1; j < n; j++) {
                if(graph[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        
        int[] parent = uf.getParent();
        int[] size = uf.getSize();
        
        int[] initialMalCount = new int[n];
        
        for(int i: initial) {
            initialMalCount[uf.find(i)]++;
        }
        
        Arrays.sort(initial);
        int maxSize = 0, maxMalIdx = initial[0];
        for(int i: initial) {
            int rootIx = uf.find(i);
            int malCount = initialMalCount[rootIx];
            if(malCount == 1) {
                int sz = size[rootIx];
                if(sz > maxSize) {
                    maxSize = sz;
                    maxMalIdx =i;
                }
            }
        }
        return maxMalIdx;
    }
}

/* Explaination
-> Method is union find
** Pseudocode:
1. From the adjacency grpah, if i and j are connected graph[i][j] = 1, malwared 
is infectious, then add the new infected node to parent, parent[i] = j; since a union operation is performed, size[j] += size[i]


in: graph[][], initial[]
// i and j connected if graph[i][j] = 1
// malwared is infectious
// M(initial) final # of nodes infected with malware
out: the node if rmv would min M(initial) with smallest value

method #0 
	sort initials increasingly
	for i in initaial
		calculate M(initial excluding i) and maintain overall minimum with i as ans
	return ans

method #1
	we don't have to emulate because only initial situation (`initials`) matters
	that's because if we construct connected component, no matter how many malwares are inside, all elements in the component will be malwared
	
    for each connected component,
        if numMalware >1, removal of one malware doesn't change anythin
        if numMalware =1, removal of one malware save the whole component, so the biggest the component, the better)
  
	we need to build a connected component and keep track of its size, that's natural to UnionFind(Disjoint Set data structure)
	
	so we
	sort initials increasingly
	for i in initaial
		check if i 's component with only one malware
		if it is, we update overall max size of such component with i as ans
	return ans
    
    Time Complexity- O(N^2) , N length of the graph.
    Space Complexity - O(N)
*/
